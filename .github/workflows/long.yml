name: Long-running task

on:
  workflow_dispatch:

jobs:
  stale:
    runs-on: ubuntu-latest
    steps:
    - run: |
        sudo pip install grilops
        cat <<EOF > a.py
        """Heyawake solver example.
        Example puzzle can be found at http://www.nikoli.co.jp/en/puzzles/heyawake.html.
        
        """
        
        from collections import defaultdict
        from z3 import And, BV2Int, BitVecVal, Concat, Extract, If, Implies, Int, PbEq, Sum, Or
        
        import grilops
        import grilops.regions
        from grilops.sightlines import reduce_cells
        
        
        HEIGHT, WIDTH = 15,15
        
        REGIONS = """AAAAAAAAABBAAAA
        AAAAAAAABBAAAAA
        AAAAAAAAAAAAAAA
        ACAAAAAAAAAAAAA
        CCAAAAAAAAAAAAA
        CAAAAAAAAAAAAAA
        AAAAADDDDAAAAAA
        AAAAAAAAAAAAAAA
        AAAAAAAAAAEAAAA
        AAAAAAFFAEEAAAA
        AAAAAFFAAEAAAAA
        AAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAA
        AAAAAAAAAAGGAAA
        AAAAAAAAAGGAAAA""".split()
        
        REGION_COUNTS = {
        		"A": 2,
        }
        
        
        def main(cnt):
        	"""Heyawake solver example."""
        	sym = grilops.SymbolSet([("B", chr(0x2588)), ("W", " ")])
        	lattice = grilops.get_rectangle_lattice(HEIGHT, WIDTH)
        	sg = grilops.SymbolGrid(lattice, sym)
        	REGION_COUNTS["A"]=cnt
        
        	# Rule 1: Painted cells may never be orthogonally connected (they may not
        	# share a side, although they can touch diagonally).
        	for i in range(HEIGHT-1):
        		for j in range(WIDTH):
        			sg.solver.add(Or([
        				sg.cell_is(grilops.Point(i,j), sym.W),
        				sg.cell_is(grilops.Point(i+1,j), sym.W),
        			]))
        	for i in range(HEIGHT):
        		for j in range(WIDTH-1):
        			sg.solver.add(Or([
        				sg.cell_is(grilops.Point(i,j), sym.W),
        				sg.cell_is(grilops.Point(i,j+1), sym.W),
        			]))
        
        	# Rule 2: All white cells must be interconnected (form a single polyomino).
        	rc = grilops.regions.RegionConstrainer(
        			lattice,
        			sg.solver,
        			complete=False)
        	white_region_id = Int("white_region_id")
        	sg.solver.add(Or(white_region_id == 0, white_region_id == 1))
        	for p in lattice.points:
        		sg.solver.add(
        				If(
        						sg.cell_is(p, sym.W),
        						rc.region_id_grid[p] == white_region_id,
        						rc.region_id_grid[p] == -1
        				)
        		)
        
        	t0=time.time()
        	# Rule 3: A number indicates exactly how many painted cells there must be in
        	# that particular room.
        	region_cells = defaultdict(list)
        	for p in lattice.points:
        		region_cells[REGIONS[p.y][p.x]].append(sg.grid[p])
        	for region, count in REGION_COUNTS.items():
        		sg.solver.add(PbEq([(c == sym.B, 1) for c in region_cells[region]], count))
        
        	# Rule 4: A room which has no number may contain any number of painted cells,
        	# or none.
        
        	# Rule 5: Where a straight (orthogonal) line of connected white cells is
        	# formed, it must not contain cells from more than two roomsâ€”in other words,
        	# any such line of white cells which connects three or more rooms is
        	# forbidden.
        	for i in range(HEIGHT-1):
        		for j in range(WIDTH):
        			if REGIONS[i][j]!=REGIONS[i+1][j]:
        				for k in range(i+2,HEIGHT):
        					if REGIONS[k][j]!=REGIONS[i+1][j]:
        						break
        				else:
        					continue
        				sg.solver.add(Or([sg.cell_is(grilops.Point(m,j), sym.B) for m in range(i,k+1)]))
        	for i in range(HEIGHT):
        		for j in range(WIDTH-1):
        			if REGIONS[i][j]!=REGIONS[i][j+1]:
        				for k in range(j+2,WIDTH):
        					if REGIONS[i][k]!=REGIONS[i][j+1]:
        						break
        				else:
        					continue
        				sg.solver.add(Or([sg.cell_is(grilops.Point(i,m), sym.B) for m in range(j,k+1)]))
        	t1=time.time()
        	print('prepare',t1-t0)
        
        	if sg.solve():
        		print('Solvable at',cnt)
        		if sg.is_unique():
        			print("Unique solution at", cnt)
        			sg.print()
        			return True
        		else:
        			print('Solvable but not unique at',cnt)
        
        import time
        for cnt in range(1,110):
        	t= time.time()
        	print('Trying', cnt)
        	if main(cnt):
        		break
        	t2= time.time()
        	print(t2-t)
        EOF
        python a.py | tee a.log
